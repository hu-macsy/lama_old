<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - data.info - dmemo/Redistributor.cpp</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">dmemo</a> - Redistributor.cpp<span style="font-size: 80%;"> (source / <a href="Redistributor.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">data.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">122</td>
            <td class="headerCovTableEntry">141</td>
            <td class="headerCovTableEntryMed">86.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-03-04 18:51:09</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">14</td>
            <td class="headerCovTableEntry">15</td>
            <td class="headerCovTableEntryHi">93.3 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**</a>
<span class="lineNum">       2 </span>            :  * @file Redistributor.cpp
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * @license
<span class="lineNum">       5 </span>            :  * Copyright (c) 2009-2017
<span class="lineNum">       6 </span>            :  * Fraunhofer Institute for Algorithms and Scientific Computing SCAI
<span class="lineNum">       7 </span>            :  * for Fraunhofer-Gesellschaft
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  * This file is part of the SCAI framework LAMA.
<span class="lineNum">      10 </span>            :  *
<span class="lineNum">      11 </span>            :  * LAMA is free software: you can redistribute it and/or modify it under the
<span class="lineNum">      12 </span>            :  * terms of the GNU Affero General Public License as published by the Free
<span class="lineNum">      13 </span>            :  * Software Foundation, either version 3 of the License, or (at your option)
<span class="lineNum">      14 </span>            :  * any later version.
<span class="lineNum">      15 </span>            :  *
<span class="lineNum">      16 </span>            :  * LAMA is distributed in the hope that it will be useful, but WITHOUT ANY
<span class="lineNum">      17 </span>            :  * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
<span class="lineNum">      18 </span>            :  * FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for
<span class="lineNum">      19 </span>            :  * more details.
<span class="lineNum">      20 </span>            :  *
<span class="lineNum">      21 </span>            :  * You should have received a copy of the GNU Affero General Public License
<span class="lineNum">      22 </span>            :  * along with LAMA. If not, see &lt;http://www.gnu.org/licenses/&gt;.
<span class="lineNum">      23 </span>            :  *
<span class="lineNum">      24 </span>            :  * Other Usage
<span class="lineNum">      25 </span>            :  * Alternatively, this file may be used in accordance with the terms and
<span class="lineNum">      26 </span>            :  * conditions contained in a signed written agreement between you and
<span class="lineNum">      27 </span>            :  * Fraunhofer SCAI. Please contact our distributor via info[at]scapos.com.
<span class="lineNum">      28 </span>            :  * @endlicense
<span class="lineNum">      29 </span>            :  *
<span class="lineNum">      30 </span>            :  * @brief Implementation of methods for Redistributor class.
<span class="lineNum">      31 </span>            :  * @author Thomas Brandes, Andreas Longva
<span class="lineNum">      32 </span>            :  * @date 08.10.2011
<span class="lineNum">      33 </span>            :  */
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : // hpp
<span class="lineNum">      36 </span>            : #include &lt;scai/dmemo/Redistributor.hpp&gt;
<span class="lineNum">      37 </span>            : #include &lt;scai/utilskernel/HArrayUtils.hpp&gt;
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : // local library
<span class="lineNum">      40 </span>            : #include &lt;scai/dmemo/HaloBuilder.hpp&gt;
<span class="lineNum">      41 </span>            : #include &lt;scai/dmemo/GeneralDistribution.hpp&gt;
<span class="lineNum">      42 </span>            : #include &lt;scai/dmemo/BlockDistribution.hpp&gt;
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : // internal scai libraries
<span class="lineNum">      45 </span>            : #include &lt;scai/common/macros/assert.hpp&gt;
<span class="lineNum">      46 </span>            : #include &lt;scai/hmemo/HostReadAccess.hpp&gt;
<span class="lineNum">      47 </span>            : #include &lt;scai/hmemo/HostWriteAccess.hpp&gt;
<span class="lineNum">      48 </span>            : #include &lt;scai/hmemo/HostWriteOnlyAccess.hpp&gt;
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            : #include &lt;memory&gt;
<span class="lineNum">      51 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            : using namespace scai::hmemo;
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : using scai::utilskernel::HArrayUtils;
<span class="lineNum">      56 </span>            : using scai::dmemo::GeneralDistribution;
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : namespace scai
<span class="lineNum">      59 </span>            : {
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            : using std::unique_ptr;
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : namespace dmemo
<span class="lineNum">      64 </span>            : {
<span class="lineNum">      65 </span>            : 
<a name="66"><span class="lineNum">      66 </span><span class="lineCov">         22 : SCAI_LOG_DEF_LOGGER( Redistributor::logger, &quot;Redistributor&quot; )</span></a>
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span><span class="lineCov">         80 : static HArray&lt;IndexType&gt; ownedGlobalIndexesForDist( const Distribution&amp; dist )</span>
<span class="lineNum">      69 </span>            : {
<span class="lineNum">      70 </span><span class="lineCov">         80 :     HArray&lt;IndexType&gt; indexes;</span>
<span class="lineNum">      71 </span><span class="lineCov">         80 :     dist.getOwnedIndexes( indexes );</span>
<span class="lineNum">      72 </span><span class="lineCov">         80 :     return indexes;</span>
<span class="lineNum">      73 </span>            : }
<span class="lineNum">      74 </span>            : 
<a name="75"><span class="lineNum">      75 </span>            : // Partitions local indexes of the source distribution into &quot;keep&quot;</a>
<span class="lineNum">      76 </span>            : // and &quot;exchange&quot;, based on the new owner of each individual index.
<span class="lineNum">      77 </span><span class="lineCov">         98 : static void partitionSourceIndexes( HArray&lt;IndexType&gt; &amp; keepLocalIndexes,</span>
<span class="lineNum">      78 </span>            :                                     HArray&lt;IndexType&gt; &amp; exchangeLocalIndexes,
<span class="lineNum">      79 </span>            :                                     const HArray&lt;PartitionId&gt; &amp; newOwnersOfLocalElements,
<span class="lineNum">      80 </span>            :                                     const Distribution&amp; sourceDist )
<span class="lineNum">      81 </span>            : {
<span class="lineNum">      82 </span><span class="lineCov">         98 :     SCAI_ASSERT_EQ_DEBUG( newOwnersOfLocalElements.size(), sourceDist.getLocalSize(), &quot;sourceDist and newOwners must have same size&quot; );</span>
<span class="lineNum">      83 </span><span class="lineCov">         98 :     const auto rank = sourceDist.getCommunicator().getRank();</span>
<span class="lineNum">      84 </span><span class="lineCov">         98 :     const auto numPartitions = sourceDist.getCommunicator().getSize();</span>
<span class="lineNum">      85 </span><span class="lineCov">         98 :     const auto sourceNumLocal = sourceDist.getLocalSize();</span>
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            :     const auto rNewOwners = hostReadAccess( newOwnersOfLocalElements );
<span class="lineNum">      88 </span>            :     auto wKeep = hostWriteOnlyAccess( keepLocalIndexes, sourceNumLocal );
<span class="lineNum">      89 </span>            :     auto wExchange = hostWriteOnlyAccess( exchangeLocalIndexes, sourceNumLocal );
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            :     IndexType numKeep = 0;
<span class="lineNum">      92 </span>            :     IndexType numExchange = 0;
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span><span class="lineCov">        351 :     for ( IndexType localSourceIndex = 0; localSourceIndex &lt; sourceDist.getLocalSize(); ++localSourceIndex )</span>
<span class="lineNum">      95 </span>            :     {
<span class="lineNum">      96 </span><span class="lineCov">        351 :         const auto newOwner = rNewOwners[localSourceIndex];</span>
<span class="lineNum">      97 </span><span class="lineCov">        351 :         SCAI_ASSERT_VALID_INDEX( newOwner, numPartitions, &quot;owner index out of range&quot; );</span>
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span><span class="lineCov">        351 :         if ( rank == newOwner )</span>
<span class="lineNum">     100 </span>            :         {
<span class="lineNum">     101 </span><span class="lineCov">        204 :             wKeep[numKeep++] = localSourceIndex;</span>
<span class="lineNum">     102 </span>            :         }
<span class="lineNum">     103 </span>            :         else
<span class="lineNum">     104 </span>            :         {
<span class="lineNum">     105 </span><span class="lineCov">        147 :             wExchange[numExchange++] = localSourceIndex;</span>
<span class="lineNum">     106 </span>            :         }
<span class="lineNum">     107 </span>            :     }
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span><span class="lineCov">         98 :     wKeep.resize( numKeep );</span>
<span class="lineNum">     110 </span><span class="lineCov">        196 :     wExchange.resize( numExchange );</span>
<span class="lineNum">     111 </span><span class="lineCov">         98 : }</span>
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            : template &lt;typename ValueType&gt;
<span class="lineNum">     114 </span><span class="lineCov">        294 : static HArray&lt;ValueType&gt; selectIndexes( const HArray&lt;ValueType&gt; &amp; source, const HArray&lt;IndexType&gt; &amp; indexes )</span>
<span class="lineNum">     115 </span>            : {
<span class="lineNum">     116 </span><span class="lineCov">        294 :     HArray&lt;ValueType&gt; result;</span>
<span class="lineNum">     117 </span><span class="lineCov">        588 :     HArrayUtils::gather( result, source, indexes, common::BinaryOp::COPY );</span>
<span class="lineNum">     118 </span><span class="lineCov">        294 :     return result;</span>
<a name="119"><span class="lineNum">     119 </span>            : }</a>
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span><span class="lineCov">        196 : static HArray&lt;IndexType&gt; local2global( const HArray&lt;IndexType&gt; &amp; localIndexes, const Distribution&amp; dist )</span>
<span class="lineNum">     122 </span>            : {
<span class="lineNum">     123 </span><span class="lineCov">        196 :     HArray&lt;IndexType&gt; globalIndexes;</span>
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span><span class="lineCov">        196 :     auto wGlobal = hostWriteOnlyAccess( globalIndexes, localIndexes.size() );</span>
<span class="lineNum">     126 </span><span class="lineCov">        196 :     auto rLocal = hostReadAccess( localIndexes );</span>
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            :     std::transform( rLocal.begin(), rLocal.end(), wGlobal.begin(),
<span class="lineNum">     129 </span>            :                     [&amp;dist] ( IndexType localIndex )
<span class="lineNum">     130 </span>            :     {
<span class="lineNum">     131 </span><span class="lineCov">        351 :         return dist.local2global( localIndex );</span>
<span class="lineNum">     132 </span><span class="lineCov">        351 :     } );</span>
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span><span class="lineCov">        196 :     return globalIndexes;</span>
<span class="lineNum">     135 </span>            : }
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span><span class="lineCov">         80 : Redistributor::Redistributor( DistributionPtr targetDistribution, DistributionPtr sourceDistribution )</span>
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span><span class="lineCov">        160 :     : mSourceDistribution( sourceDistribution ), mTargetDistribution( targetDistribution )</span>
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span>            : {
<span class="lineNum">     142 </span><span class="lineCov">        400 :     SCAI_ASSERT_ERROR( sourceDistribution, &quot;source distribution is not allowed to be null&quot; )</span>
<span class="lineNum">     143 </span><span class="lineCov">        320 :     SCAI_ASSERT_ERROR( targetDistribution, &quot;target distribution is not allowed to be null&quot; )</span>
<span class="lineNum">     144 </span><span class="lineCov">        160 :     SCAI_ASSERT_EQ_ERROR( sourceDistribution-&gt;getCommunicator(), targetDistribution-&gt;getCommunicator(),</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :                           &quot;source and target distributions must have the same communicator&quot; );</span>
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span><span class="lineCov">         80 :     HArray&lt;PartitionId&gt; targetOwners;</span>
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span><span class="lineCov">         80 :     const auto commSize = sourceDistribution-&gt;getCommunicator().getSize();</span>
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span><span class="lineCov">         80 :     if ( targetDistribution-&gt;hasAnyAddressing() || commSize &lt;= 2 )</span>
<span class="lineNum">     152 </span>            :     {
<span class="lineNum">     153 </span>            :         // Computing owners is cheap, so do so directly
<span class="lineNum">     154 </span><span class="lineCov">         73 :         HArray&lt;PartitionId&gt; sourceGlobalIndexes;</span>
<span class="lineNum">     155 </span><span class="lineCov">         73 :         sourceDistribution-&gt;getOwnedIndexes( sourceGlobalIndexes );</span>
<span class="lineNum">     156 </span><span class="lineCov">         73 :         targetDistribution-&gt;computeOwners( targetOwners, sourceGlobalIndexes );</span>
<span class="lineNum">     157 </span>            :     }
<span class="lineNum">     158 </span>            :     else
<span class="lineNum">     159 </span>            :     {
<span class="lineNum">     160 </span>            :         // Building the necessary data structures for a Redistributor usually relies
<span class="lineNum">     161 </span>            :         // on determining where to send the data. For some distributions, computing owners is cheap,
<span class="lineNum">     162 </span>            :         // whereas for others (such as general distributions), this is an expensive process.
<span class="lineNum">     163 </span>            :         // In the case that computing owners directly is expensive, we can recover them in
<span class="lineNum">     164 </span>            :         // an asymptotically speaking far cheaper way by going through an intermediate
<span class="lineNum">     165 </span>            :         // distribution for which we *can* compute the owners cheaply (e.g. block, cyclic, ...).
<span class="lineNum">     166 </span>            :         //
<span class="lineNum">     167 </span>            :         // The approach below is attributed to Moritz von Looz-Corswarem, who
<span class="lineNum">     168 </span>            :         // pointed out the optimization opportunity to us, and provided source code and experimental
<span class="lineNum">     169 </span>            :         // results to show its efficacy. The code below is loosely based on his original code.
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span><span class="lineCov">          7 :         const auto globalSize = sourceDistribution-&gt;getGlobalSize();</span>
<span class="lineNum">     172 </span><span class="lineCov">          7 :         const auto comm = sourceDistribution-&gt;getCommunicatorPtr();</span>
<span class="lineNum">     173 </span><span class="lineCov">          7 :         const auto rank = comm-&gt;getRank();</span>
<span class="lineNum">     174 </span>            :         const auto intermediateDist = std::make_shared&lt;BlockDistribution&gt;( globalSize, comm );
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span><span class="lineCov">         28 :         SCAI_LOG_INFO( logger, &quot;build Redistributor via intermediate dist = &quot; &lt;&lt; *intermediateDist )</span>
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span><span class="lineCov">         28 :         Redistributor targetToIntermediate( intermediateDist, targetDistribution );</span>
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span>            :         // Note: source to intermediate first, then reverse
<span class="lineNum">     181 </span><span class="lineCov">         28 :         Redistributor intermediateToSource( intermediateDist, sourceDistribution );</span>
<span class="lineNum">     182 </span><span class="lineCov">          7 :         intermediateToSource.reverse();</span>
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            :         // In order to find out what the owners in target of the source global indexes are,
<span class="lineNum">     185 </span>            :         // we work our way backwards from target. We know that all local elements in target
<span class="lineNum">     186 </span>            :         // have owner equal to the rank, and since redistribution does not change the
<span class="lineNum">     187 </span>            :         // associated global index of the elements, we can simply redistribute the owners
<span class="lineNum">     188 </span>            :         // (which start out as all identical to rank) through the intermediate distribution
<span class="lineNum">     189 </span>            :         // and finally to the source in order to recover the desired new owner for
<span class="lineNum">     190 </span>            :         // each local source index.
<span class="lineNum">     191 </span><span class="lineCov">         14 :         HArray&lt;PartitionId&gt; ownersInTarget( targetDistribution-&gt;getLocalSize(), rank );</span>
<span class="lineNum">     192 </span><span class="lineCov">          7 :         HArray&lt;PartitionId&gt; ownersInIntermediate;</span>
<span class="lineNum">     193 </span><span class="lineCov">          7 :         targetToIntermediate.redistribute( ownersInIntermediate, ownersInTarget );</span>
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            :         // Reuse storage in order to possibly avoid allocation (depending on relative sizes)
<span class="lineNum">     196 </span>            :         auto ownersInSource = std::move( ownersInTarget );
<span class="lineNum">     197 </span><span class="lineCov">          7 :         intermediateToSource.redistribute( ownersInSource, ownersInIntermediate );</span>
<span class="lineNum">     198 </span>            :         targetOwners = std::move ( ownersInSource );
<span class="lineNum">     199 </span>            :     }
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span><span class="lineCov">         80 :     const auto targetGlobalIndexes = initializeFromNewOwners( targetOwners, *sourceDistribution );</span>
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span><span class="lineCov">        240 :     SCAI_ASSERT_DEBUG(</span>
<span class="lineNum">     205 </span>            :         HArrayUtils::all ( targetGlobalIndexes, common::CompareOp::EQ, ownedGlobalIndexesForDist( *targetDistribution ) ),
<span class="lineNum">     206 </span>            :         &quot;Internal error: mismatch between expected global indexes and target distribution&quot; );
<span class="lineNum">     207 </span><span class="lineCov">         80 : }</span>
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span><span class="lineCov">         18 : Redistributor::Redistributor( const scai::hmemo::HArray&lt; PartitionId &gt;&amp; newOwnersOfLocalElements, DistributionPtr sourceDistribution )</span>
<span class="lineNum">     212 </span><span class="lineCov">         36 :     :   mSourceDistribution( sourceDistribution )</span>
<span class="lineNum">     213 </span>            : {
<span class="lineNum">     214 </span><span class="lineCov">         54 :     SCAI_ASSERT_ERROR( sourceDistribution, &quot;source distribution is not allowed to be null&quot; );</span>
<span class="lineNum">     215 </span><span class="lineCov">         18 :     SCAI_ASSERT_EQ_ERROR( newOwnersOfLocalElements.size(), sourceDistribution-&gt;getLocalSize(),</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :                           &quot;size of new owners must be equal to local size of distribution&quot; );</span>
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span><span class="lineCov">         18 :     const auto targetGlobalIndexes = initializeFromNewOwners( newOwnersOfLocalElements, *sourceDistribution );</span>
<span class="lineNum">     219 </span><span class="lineCov">         54 :     mTargetDistribution = DistributionPtr ( new GeneralDistribution( sourceDistribution-&gt;getGlobalSize(),</span>
<span class="lineNum">     220 </span>            :                                             targetGlobalIndexes,
<span class="lineNum">     221 </span><span class="lineCov">         18 :                                             sourceDistribution-&gt;getCommunicatorPtr() ) );</span>
<span class="lineNum">     222 </span><span class="lineCov">         18 : }</span>
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span>            : // Note: returns global target indexes
<span class="lineNum">     225 </span><span class="lineCov">         98 : HArray&lt;IndexType&gt; Redistributor::initializeFromNewOwners( const hmemo::HArray&lt;PartitionId&gt; &amp; newOwnersOfLocalElements, const Distribution&amp; sourceDist )</span>
<span class="lineNum">     226 </span>            : {
<span class="lineNum">     227 </span><span class="lineCov">         98 :     const auto sourceNumLocal = sourceDist.getLocalSize();</span>
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span><span class="lineCov">         98 :     SCAI_ASSERT_EQ_ERROR( sourceNumLocal, newOwnersOfLocalElements.size(),</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :                           &quot;Array of owners must have size equal to number of local values in source distribution.&quot; );</span>
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span><span class="lineCov">         98 :     HArray&lt;IndexType&gt; providedSourceIndexes;</span>
<span class="lineNum">     233 </span><span class="lineCov">         98 :     partitionSourceIndexes( mKeepSourceIndexes, providedSourceIndexes, newOwnersOfLocalElements, sourceDist );</span>
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span><span class="lineCov">         98 :     const auto globalKeepIndexes = local2global ( mKeepSourceIndexes, sourceDist );</span>
<span class="lineNum">     236 </span><span class="lineCov">         98 :     const auto globalProvidedIndexes = local2global( providedSourceIndexes, sourceDist );</span>
<span class="lineNum">     237 </span><span class="lineCov">         98 :     const auto newOwnersOfProvided = selectIndexes( newOwnersOfLocalElements, providedSourceIndexes );</span>
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span>            :     // We only put the exchange indexes into the Halo, as this might work considerably better when
<span class="lineNum">     240 </span>            :     // most elements are kept (present both in source and target dist). This means that the Halo is working
<span class="lineNum">     241 </span>            :     // with the index set given by our exchange indexes rather than local indexes of the source distribution
<span class="lineNum">     242 </span><span class="lineCov">        196 :     Halo exchangeHalo;</span>
<span class="lineNum">     243 </span><span class="lineCov">         98 :     HaloBuilder::buildFromProvidedOwners( sourceDist.getCommunicator(), globalProvidedIndexes, newOwnersOfProvided, exchangeHalo );</span>
<span class="lineNum">     244 </span>            :     mExchangeReceivePlan = exchangeHalo.getRequiredPlan();
<span class="lineNum">     245 </span>            :     mExchangeSendPlan = exchangeHalo.getProvidesPlan();
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span><span class="lineCov">         98 :     HArray&lt;IndexType&gt; sortedRequiredIndexes;</span>
<span class="lineNum">     248 </span><span class="lineCov">         98 :     HArray&lt;IndexType&gt; sortPermutation;</span>
<span class="lineNum">     249 </span><span class="lineCov">        196 :     HArrayUtils::sort( &amp;sortPermutation, &amp;sortedRequiredIndexes, exchangeHalo.getRequiredIndexes(), true );</span>
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span><span class="lineCov">         98 :     HArray&lt;IndexType&gt; targetGlobalIndexes;</span>
<span class="lineNum">     252 </span><span class="lineCov">         98 :     HArray&lt;IndexType&gt; mapFromExchangeToTarget;</span>
<span class="lineNum">     253 </span><span class="lineCov">        196 :     HArrayUtils::mergeAndMap( targetGlobalIndexes, mapFromExchangeToTarget, mKeepTargetIndexes, sortedRequiredIndexes, globalKeepIndexes );</span>
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            :     // Repurpose the storage of sortedRequiredIndexes (same size and type as inversePerm) to further additional memory allocation
<span class="lineNum">     256 </span>            :     auto inversePerm = std::move( sortedRequiredIndexes );
<span class="lineNum">     257 </span><span class="lineCov">        196 :     HArrayUtils::inversePerm( inversePerm, sortPermutation );</span>
<span class="lineNum">     258 </span><span class="lineCov">        196 :     mExchangeSourceIndexes = selectIndexes( providedSourceIndexes, exchangeHalo.getProvidesIndexes() );</span>
<span class="lineNum">     259 </span><span class="lineCov">        196 :     mExchangeTargetIndexes = selectIndexes( mapFromExchangeToTarget, inversePerm );</span>
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span><span class="lineCov">         98 :     return targetGlobalIndexes;</span>
<span class="lineNum">     262 </span>            : }
<span class="lineNum">     263 </span>            : 
<a name="264"><span class="lineNum">     264 </span>            : /* -------------------------------------------------------------------------- */</a>
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span><span class="lineCov">         11 : void Redistributor::writeAt( std::ostream&amp; stream ) const</span>
<span class="lineNum">     267 </span>            : {
<span class="lineNum">     268 </span><span class="lineCov">         11 :     stream &lt;&lt; &quot;Redistributor( &quot;;</span>
<span class="lineNum">     269 </span><span class="lineCov">         11 :     stream &lt;&lt; *mSourceDistribution &lt;&lt; &quot;-&gt;&quot; &lt;&lt; *mTargetDistribution;</span>
<span class="lineNum">     270 </span><span class="lineCov">         11 :     stream &lt;&lt; &quot;, &quot; &lt;&lt; getSourceLocalSize() &lt;&lt; &quot;-&gt;&quot; &lt;&lt; getTargetLocalSize();</span>
<span class="lineNum">     271 </span><span class="lineCov">         11 :     stream &lt;&lt; &quot;, local:&quot; &lt;&lt; getNumLocalValues();</span>
<span class="lineNum">     272 </span><span class="lineCov">         11 :     stream &lt;&lt; &quot;, source halo :&quot; &lt;&lt; getExchangeSourceSize();</span>
<span class="lineNum">     273 </span><span class="lineCov">         11 :     stream &lt;&lt; &quot;, target halo :&quot; &lt;&lt; getExchangeTargetSize();</span>
<span class="lineNum">     274 </span><span class="lineCov">         11 :     stream &lt;&lt; &quot;)&quot;;</span>
<span class="lineNum">     275 </span><span class="lineCov">         11 : }</span>
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            : /* -------------------------------------------------------------------------- */
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span><span class="lineCov">          7 : DistributionPtr Redistributor::getSourceDistributionPtr() const</span>
<span class="lineNum">     280 </span>            : {
<span class="lineNum">     281 </span><span class="lineCov">          7 :     return mSourceDistribution;</span>
<span class="lineNum">     282 </span>            : }
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span>            : /* -------------------------------------------------------------------------- */
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span><span class="lineCov">          7 : DistributionPtr Redistributor::getTargetDistributionPtr() const</span>
<span class="lineNum">     287 </span>            : {
<span class="lineNum">     288 </span><span class="lineCov">          7 :     return mTargetDistribution;</span>
<span class="lineNum">     289 </span>            : }
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span><span class="lineCov">          7 : void Redistributor::reverse()</span>
<span class="lineNum">     292 </span>            : {
<span class="lineNum">     293 </span><span class="lineCov">          7 :     std::swap( mExchangeReceivePlan, mExchangeSendPlan );</span>
<span class="lineNum">     294 </span>            :     std::swap( mSourceDistribution, mTargetDistribution );
<span class="lineNum">     295 </span><span class="lineCov">          7 :     std::swap( mKeepSourceIndexes, mKeepTargetIndexes );</span>
<span class="lineNum">     296 </span><span class="lineCov">          7 :     std::swap( mExchangeSourceIndexes, mExchangeTargetIndexes );</span>
<span class="lineNum">     297 </span>            :     std::swap( mRequiredPlan, mProvidesPlan );
<span class="lineNum">     298 </span><span class="lineCov">          7 : }</span>
<span class="lineNum">     299 </span>            : 
<a name="300"><span class="lineNum">     300 </span>            : /* -------------------------------------------------------------------------- */</a>
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span><span class="lineNoCov">          0 : void Redistributor::buildVPlans( const IndexType haloSourceSizes[], const IndexType haloTargetSizes[] ) const</span>
<span class="lineNum">     303 </span>            : {
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :     const IndexType numProvides = mExchangeSendPlan.totalQuantity();</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :     const IndexType numRequired = mExchangeReceivePlan.totalQuantity();</span>
<span class="lineNum">     306 </span>            :     // calculate number of provided and required values by summing up the corresponding quantities
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :     unique_ptr&lt;IndexType[]&gt; provideQuantities( new IndexType[numProvides] );</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :     unique_ptr&lt;IndexType[]&gt; requiredQuantities( new IndexType[numRequired] );</span>
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span>            :     // For building the new schedule we need the sizes, can be calculated by the offsets
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :     for ( IndexType i = 0; i &lt; numProvides; i++ )</span>
<span class="lineNum">     313 </span>            :     {
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :         IndexType size = haloSourceSizes[i];</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :         provideQuantities[i] = size;</span>
<span class="lineNum">     316 </span>            :         SCAI_LOG_DEBUG( logger, &quot;provides[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; size )
<span class="lineNum">     317 </span>            :     }
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :     for ( IndexType i = 0; i &lt; numRequired; i++ )</span>
<span class="lineNum">     320 </span>            :     {
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :         IndexType size = haloTargetSizes[i];</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :         requiredQuantities[i] = size;</span>
<span class="lineNum">     323 </span>            :         SCAI_LOG_DEBUG( logger, &quot;required[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; size )
<span class="lineNum">     324 </span>            :     }
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :     mProvidesPlan.reset( new CommunicationPlan( mExchangeSendPlan, provideQuantities.get() ) );</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :     mRequiredPlan.reset( new CommunicationPlan( mExchangeReceivePlan, requiredQuantities.get() ) );</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :     SCAI_LOG_INFO( logger, &quot;providesPlan = &quot; &lt;&lt; *mProvidesPlan )</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :     SCAI_LOG_INFO( logger, &quot;requiredPlan = &quot; &lt;&lt; *mRequiredPlan )</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            : /* -------------------------------------------------------------------------- */
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span><span class="lineCov">         11 : void Redistributor::buildRowPlans(</span>
<span class="lineNum">     335 </span>            :     const HArray&lt;IndexType&gt;&amp; targetSizes,
<span class="lineNum">     336 </span>            :     const HArray&lt;IndexType&gt;&amp; sourceSizes ) const
<span class="lineNum">     337 </span>            : {
<span class="lineNum">     338 </span><span class="lineCov">         11 :     const IndexType numProvides = mExchangeSendPlan.totalQuantity();</span>
<span class="lineNum">     339 </span><span class="lineCov">         11 :     const IndexType numRequired = mExchangeReceivePlan.totalQuantity();</span>
<span class="lineNum">     340 </span>            :     // calculate number of provided and required values by summing up the corresponding quantities
<span class="lineNum">     341 </span><span class="lineCov">         11 :     unique_ptr&lt;IndexType[]&gt; provideQuantities( new IndexType[numProvides] );</span>
<span class="lineNum">     342 </span><span class="lineCov">         11 :     unique_ptr&lt;IndexType[]&gt; requiredQuantities( new IndexType[numRequired] );</span>
<span class="lineNum">     343 </span>            :     ContextPtr contextPtr = Context::getHostPtr();
<span class="lineNum">     344 </span>            :     // For building the new schedule we need the sizes, can be calculated by the offsets
<span class="lineNum">     345 </span>            :     {
<span class="lineNum">     346 </span><span class="lineCov">         22 :         ReadAccess&lt;IndexType&gt; indexes( mExchangeSourceIndexes, contextPtr );</span>
<span class="lineNum">     347 </span><span class="lineCov">         22 :         ReadAccess&lt;IndexType&gt; sizes( sourceSizes, contextPtr );</span>
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span><span class="lineCov">         27 :         for ( IndexType i = 0; i &lt; numProvides; i++ )</span>
<span class="lineNum">     350 </span>            :         {
<span class="lineNum">     351 </span><span class="lineCov">         16 :             IndexType size = sizes[indexes[i]];</span>
<span class="lineNum">     352 </span><span class="lineCov">         16 :             provideQuantities[i] = size;</span>
<span class="lineNum">     353 </span>            :             SCAI_LOG_DEBUG( logger, &quot;provides[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; size )
<span class="lineNum">     354 </span>            :         }
<span class="lineNum">     355 </span>            :     }
<span class="lineNum">     356 </span>            :     {
<span class="lineNum">     357 </span><span class="lineCov">         22 :         ReadAccess&lt;IndexType&gt; indexes( mExchangeTargetIndexes, contextPtr );</span>
<span class="lineNum">     358 </span><span class="lineCov">         22 :         ReadAccess&lt;IndexType&gt; sizes( targetSizes, contextPtr );</span>
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span><span class="lineCov">         27 :         for ( IndexType i = 0; i &lt; numRequired; i++ )</span>
<span class="lineNum">     361 </span>            :         {
<span class="lineNum">     362 </span><span class="lineCov">         16 :             IndexType size = sizes[indexes[i]];</span>
<span class="lineNum">     363 </span><span class="lineCov">         16 :             requiredQuantities[i] = size;</span>
<span class="lineNum">     364 </span>            :             SCAI_LOG_DEBUG( logger, &quot;required[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; size )
<span class="lineNum">     365 </span>            :         }
<span class="lineNum">     366 </span>            :     }
<span class="lineNum">     367 </span><span class="lineCov">         11 :     mProvidesPlan.reset( new CommunicationPlan( mExchangeSendPlan, provideQuantities.get() ) );</span>
<span class="lineNum">     368 </span><span class="lineCov">         11 :     mRequiredPlan.reset( new CommunicationPlan( mExchangeReceivePlan, requiredQuantities.get() ) );</span>
<span class="lineNum">     369 </span><span class="lineCov">         55 :     SCAI_LOG_INFO( logger, &quot;providesPlan = &quot; &lt;&lt; *mProvidesPlan )</span>
<span class="lineNum">     370 </span><span class="lineCov">         55 :     SCAI_LOG_INFO( logger, &quot;requiredPlan = &quot; &lt;&lt; *mRequiredPlan )</span>
<span class="lineNum">     371 </span><span class="lineCov">         11 : }</span>
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            : /* ========================================================================= */
<span class="lineNum">     374 </span>            : /*       Template Instantiations                                             */
<span class="lineNum">     375 </span>            : /* ========================================================================= */
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span>            : /*
<span class="lineNum">     378 </span>            :  template COMMON_DLL_IMPORTEXPORT
<span class="lineNum">     379 </span>            :  void Redistributor::redistributeN ( HArray&lt;float&gt;&amp; targetArray,
<span class="lineNum">     380 </span>            :  const HArray&lt;float&gt;&amp; sourceArray,
<span class="lineNum">     381 </span>            :  IndexType n ) const;
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            :  template COMMON_DLL_IMPORTEXPORT
<span class="lineNum">     384 </span>            :  void Redistributor::redistributeN ( HArray&lt;double&gt;&amp; targetArray,
<span class="lineNum">     385 </span>            :  const HArray&lt;double&gt;&amp; sourceArray,
<span class="lineNum">     386 </span>            :  IndexType n ) const;
<span class="lineNum">     387 </span>            :  */
<span class="lineNum">     388 </span>            : 
<a name="389"><span class="lineNum">     389 </span>            : } /* end namespace dmemo */</a>
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span><span class="lineCov">         33 : } /* end namespace scai */</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
