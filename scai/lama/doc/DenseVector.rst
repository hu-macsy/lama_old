.. _lama_DenseVector:

DenseVector
===========

The class ``DenseVector`` is a container class and any object of this class stands for a one-dimensional array with values
of a certain type. In contrary to the ``HArray``, a ``DenseVector`` is distributed among processors by having
a specific ``Distribution`` from :ref:`scaidmemo:main-page_dmemo`.
For a distributed vector, each processor stores only the values owned by it. 
These owned local values are internally stored in a ``HArray`` (see :ref:`scaihmemo:main-page_hmemo`)
so a ``DenseVector`` can be used transparently on every device. 

Constructors
------------

In order to create a dense vector you might call one of the constructors of the template class ``DenseVector``, 
The most essential constructor takes a distribution and the array with the local values to build the dense
vector.

.. code-block:: c++

    const IndexType size = 980;
    DistributionPtr blockDist =  blockDistribution( size );
    HArray<ValueType> localValues = ...;   //   must have blockDist->getLocalSize() entries

    DenseVector<ValueType> vector( blockDist, localValues[, ctx] );

The context argument of a vector decides where operations on this vector will be executed. It
is optional, by default the context is the currently actual context (as specified by the environment
variable ``SCAI_CONTEXT``).

A dense vector with an initial value is very typical:

.. code-block:: c++

    ValueType initVal = 1;
    DenseVector<ValueType> vector( blockDist, initVal[, ctx] );
    // same as vector( blockDist, HArray<ValueType>( blockDist.getLocalSize(), initVal )
    DenseVector( blockDist, HArray<ValueType>( blockDist.getLocalSize(), initVal )[, ctx] );

You might also create a replicated dense vector, i.e. a full dense vector, that has an incarnation
on each processor. Therefore you can use the class ``NoDistribution`` for specifying the distribution,
or you might use the size argument directly instead of a distribution argument.

.. code-block:: c++

    const IndexType n = 1024;
    ValueType initVal = 1;
    HArray<ValueType> values = ...;
    DenseVector<ValueType> vector1( n initVal[, ctx] );     // vector1( noDist, initVal )
    DenseVector<ValueType> vector2( localValues[, ctx] );   // vector2( noDist, localValues )

The use of the following constructors is not really recommended as it results in vector that have
undefined values.

.. code-block:: c++

    DenseVector<ValueType> vectorUndefined( blockDist );

Furthermore, keep in mind that the size of a vector or a distributon is set or changed by most operations
on vectors and so this attribute does not hold for the lifetime of a vector at all.

Free Functions with DenseVector Result
--------------------------------------

.. code-block:: c++

    const auto vector1 = denseVectorLinear<ValueType>( dist, firstVal, incVal );
    const auto vector2 = denseVectorZero<ValueType>( dist, zero );
    const auto vector3 = denseVectorEval( matrix * x );
    const auto vector4 = denseVectorRead( "matrix.frm" )
    const auto vector5 = denseVectorRead( file )

.. code-block:: c++

    template<typename ValueType>                  template<typename ValueType>
    DenseVector<ValueType> freeFunction( ... )    void subroutine( DenseVector<ValueType>& v, ... )
    {                                             {
        DenseVector<ValueType> v( ... );               v = ...;
        ...                                            ...
        return v;                                 }
    }


Dense Vector Methods
--------------------

DenseVector is a derived class from the generic class ``Vector``, so all methods and 
operations provided by this class are also available for the ``DenseVector`` class.

FFT
---

The following example shows how to call the Fast Fourier Transform for a vector (in-place):

.. code-block:: c++

   #include<scai/lama/fft.hpp>

   auto x = denseVectorRead<ComplexDouble>( "input.mtx" );

   // Note: size of x must be a power of 2

   fft( x );    // apply fast fourier transform
   ifft( x );   // apply inverse fast fourier transform

   x.writeToFile( "output.mtx" );

Here are some remarks about calling fft or ifft for a vector:

 * The size of the vector must be a power of 2
 * The distribution does not change but it might be redistributed intermeadiately
 * The value type of the vector must be a complex type.

Good Practice Advices
---------------------

A vector is not a container class where elements can easily be added or removed. Therfore other C++
container classes should be used, and a LAMA vector should only be generated by the final data.

Like for all container classes, a dense vector allocates memory when it is constructed.
This allocation is not cheap at all and therefore vectors should be reused wherever possible.
Especially reuse in loops should have rather high priority in order to achieve good performance.

.. code-block:: c++

    auto x = denseVector( blockDistribution( N ), ValueType( 0 ) );

    // bad practice                                       // good practice
    for ( IndexType i = 0; i < NITER; ++i )               DenseVector<ValueType> v;
    {                                                     for ( IndexType i = 0; i < NITER; ++i )
        auto v = denseVectorEval( matrix * x );           {
        x = x + alpha * v;                                    v = matrix * x;
        ...                                                   x = x + alpha * v;
    }                                                         ....

                                                          }

Even if the size or distribution of a vector might change during its lifetime, it is recommended
to avoid these operations, i.e. a dense vector should be allocated once with its size as used
for the application.

