
The CPU and GPU conflict
========================

Efficient OpenMP solutions are often not directly portable. Optimized algorithms on CPUS work in such a way that one
thread works on contiguous data. Optimized algorithms on GPUs work in such a way that threads work .
For many algorithms this conflict can be solved by having an inner loop that is vectorized and this loop is used 
also for the parallelization of the threads in one warp.

Supported matrix formats.

CSR is the most efficient format for CPUs. Unfortunately it is not the best for GPUs where the threads of one warp should access the data by stride 1.

ELL is the most efficient for GPUs but stores non-zero elements.

JDS is only supported by LAMA. 

DIA is very efficient but only for very special matrices. It does not require additional memory accesses for the column indexes.

COO has its main purpose for internal algorithms. Conversion from COO to CSR is very simple if the elements are sorted by the row
indexes. Sorting by the column indexes corresponds the CSC format. Therefore it is the best candidate for conversions between
CSR and CSC as needed by all transpose operations on matrices. Sparse matrix-vector multiplication is very inefficient for unsorted data.

